# IEBrowser

## TODO

- 编写进程间通信用的一对多通信器;
- ~~编写 BrowserManager 类，用来管理 IEBrowserThread~~

## Bug

## Fixed Bug

- 如果为 `IEBrowserThread::Initialize()` 传入父窗口句柄(在主线程中创建)，就会卡死。
    - 问题原因：没有找到，推测是父子窗口的问题；
    - 解决方法：每次创建窗口时先不传入父窗口句柄，创建完毕后使用 SetParent 来设置父窗口句柄。

- 传入父窗口句柄的情况下，反初始化 IEBrowser 时会卡死
    - 问题原因可能有下面几点：
        - IEBrowser 和 父窗口之间有联动关系，而这两个窗口不在同一个线程，有可能在销毁 IEBrowser 的时候，系统内部发了一些同步消息等待父窗口处理，但父窗口此时处于阻塞状态。因而造成了死锁；
        - IEBrowser 窗口销毁的位置是在 消息循环 退出以后，有可能窗口销毁时需要向消息队列发送消息，并等待消息被处理完毕。而消息循环已经退出，导致这些消息无法被处理，从而造成了卡死；
        - 主线程销毁 IEBrowser 时，先向浏览器线程发送一条退出消息，然后就使用 `thread.join()` 等待线程退出，这个时候主线程进入阻塞状态，无法处理任何消息。有可能在 IEBrowser 的销毁过程中会向主线程发送一些消息并等待，这会导致死锁；
    - 解决方法：
        - IEBrowser 反初始化时先解除父子关系；
        - IEBrowser 反初始化操作在消息循环里做，反初始化完毕后再投递 `WM_QUIT` 消息，这样 IEBrowser 窗口销毁的过程中消息还能正常投递并处理；
        - 修改原来的等待机制，原先的等待是使用 `thread.join()`, `condition_variable.wait()` 这样的方法，这会阻塞主线程。改为使用 `while(GetMessage())` 这样的消息循环来等待对端通知。这样的话，主线程在销毁的过程中还可以处理别的消息。